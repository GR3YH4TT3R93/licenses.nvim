local make_builtin = require("null-ls.helpers").make_builtin
local methods = require("null-ls.methods")
local h = require("null-ls.helpers.cspell")

local CODE_ACTION = methods.internal.CODE_ACTION

---@class AddToDictionaryAction
---@field diagnostic Diagnostic
---@field word string
---@field params GeneratorParams
---@field cspell CSpellConfigInfo
---@field dictionary CSpellDictionary

---@param opts AddToDictionaryAction
---@return CodeAction
local function make_add_to_dictionary_action(opts)
    ---@type CSpellSourceConfig
    local code_action_config = opts.params:get_config()
    local on_success = code_action_config.on_success

    return {
        title = 'Add "' .. opts.word .. '" to dictionary "' .. opts.dictionary.name .. '"',
        action = function()
            if opts.dictionary == nil then
                return
            end
            local dictionary_path = vim.fn.expand(opts.dictionary.path)
            local dictionary_ok, dictionary_body = pcall(vim.fn.readfile, dictionary_path)
            if not dictionary_ok then
                vim.notify("Can't read " .. dictionary_path, vim.log.levels.ERROR)
                return
            end
            table.insert(dictionary_body, opts.word)

            vim.fn.writefile(dictionary_body, dictionary_path)
            vim.notify('Added "' .. opts.word .. '" to ' .. opts.dictionary.path, vim.log.levels.INFO)

            -- replace word in buffer to trigger cspell to update diagnostics
            h.set_word(opts.diagnostic, opts.word)

            if on_success then
                on_success(opts.cspell.path, opts.params, "add_to_dictionary")
            end
        end,
    }
end

---@class AddToJSONAction
---@field diagnostic Diagnostic
---@field word string
---@field params GeneratorParams
---@field cspell CSpellConfigInfo|nil

---@param opts AddToJSONAction
---@return CodeAction
local function make_add_to_json(opts)
    ---@type CSpellSourceConfig
    local code_action_config = opts.params:get_config()
    local on_success = code_action_config.on_success
    local encode_json = code_action_config.encode_json or vim.json.encode

    return {
        title = 'Add "' .. opts.word .. '" to cspell json file',
        action = function()
            local cspell = opts.cspell or h.create_cspell_json(opts.params)

            if not cspell.config.words then
                cspell.config.words = {}
            end

            table.insert(cspell.config.words, opts.word)

            local encoded = encode_json(cspell.config) or ""
            local lines = {}
            for line in encoded:gmatch("[^\r\n]+") do
                table.insert(lines, line)
            end

            vim.fn.writefile(lines, cspell.path)

            -- replace word in buffer to trigger cspell to update diagnostics
            h.set_word(opts.diagnostic, opts.word)

            if on_success then
                on_success(cspell.path, opts.params, "add_to_json")
            end
        end,
    }
end

--- Filter diagnostics generated by the cspell built-in
---@param bufnr number
---@param lnum number
---@param cursor_col number
---@return table<number, Diagnostic>
local cspell_diagnostics = function(bufnr, lnum, cursor_col)
    local diagnostics = {}
    for _, diagnostic in ipairs(vim.diagnostic.get(bufnr, { lnum = lnum })) do
        if diagnostic.source == "cspell" and cursor_col >= diagnostic.col and cursor_col < diagnostic.end_col then
            table.insert(diagnostics, diagnostic)
        end
    end
    return diagnostics
end

return make_builtin({
    name = "cspell",
    meta = {
        url = "https://github.com/streetsidesoftware/cspell",
        description = "Injects actions to fix typos found by `cspell`.",
        notes = {
            "This source depends on the `cspell` built-in diagnostics source, so make sure to register it, too.",
        },
        usage = "local sources = { null_ls.builtins.diagnostics.cspell, null_ls.builtins.code_actions.cspell }",
    },
    method = CODE_ACTION,
    filetypes = {},
    generator = {
        ---@param params GeneratorParams
        ---@return table<number, CodeAction>
        fn = function(params)
            params.cwd = params.cwd or vim.loop.cwd()

            ---@type table<number, CodeAction>
            local actions = {}

            local cspell = h.async_get_config_info(params)

            local diagnostics = cspell_diagnostics(params.bufnr, params.row - 1, params.col)
            if vim.tbl_isempty(diagnostics) then
                return actions
            end

            for _, diagnostic in ipairs(diagnostics) do
                -- replace word with a suggestion
                for _, suggestion in ipairs(diagnostic.user_data.suggestions) do
                    table.insert(actions, {
                        title = string.format("Use %s", suggestion),
                        action = function()
                            h.set_word(diagnostic, suggestion)

                            ---@type CSpellSourceConfig
                            local code_action_config = params:get_config()
                            local on_success = code_action_config.on_success

                            if on_success then
                                on_success(cspell and cspell.path, params, "use_suggestion")
                            end
                        end,
                    })
                end

                local word = h.get_word(diagnostic)

                -- add word to "words" in cspell.json
                table.insert(
                    actions,
                    make_add_to_json({
                        diagnostic = diagnostic,
                        word = word,
                        params = params,
                        cspell = cspell,
                    })
                )

                if cspell == nil then
                    break
                end

                -- add word to a custom dictionary
                for _, dictionary in ipairs(cspell.config.dictionaryDefinitions or {}) do
                    if dictionary ~= nil and dictionary.addWords then
                        table.insert(
                            actions,
                            make_add_to_dictionary_action({
                                diagnostic = diagnostic,
                                word = word,
                                params = params,
                                cspell = cspell,
                                dictionary = dictionary,
                            })
                        )
                    end
                end
            end

            return actions
        end,
    },
})
